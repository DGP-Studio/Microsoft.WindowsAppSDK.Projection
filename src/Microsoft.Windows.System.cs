//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.2.0.241111.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Microsoft.Windows.System
{
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.System")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.System.EnvironmentManager))]
    [global::ABI.Microsoft.Windows.System.EnvironmentManagerRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IEnvironmentManager))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(EnvironmentManagerContract), 65536u)]
    public sealed class EnvironmentManager : global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<EnvironmentManager>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Windows_System_IEnvironmentManager => _inner;
        private volatile IObjectReference ___objRef_global__Microsoft_Windows_System_IEnvironmentManager2;
        private IObjectReference Make___objRef_global__Microsoft_Windows_System_IEnvironmentManager2()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__Microsoft_Windows_System_IEnvironmentManager2, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.Microsoft.Windows.System.IEnvironmentManager2Methods.IID), null);
            return ___objRef_global__Microsoft_Windows_System_IEnvironmentManager2;
        }
        private IObjectReference _objRef_global__Microsoft_Windows_System_IEnvironmentManager2 => ___objRef_global__Microsoft_Windows_System_IEnvironmentManager2 ?? Make___objRef_global__Microsoft_Windows_System_IEnvironmentManager2();



        public static I As<I>() => ActivationFactory.Get("Microsoft.Windows.System.EnvironmentManager").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics;
        private static IObjectReference _objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics = ActivationFactory.Get("Microsoft.Windows.System.EnvironmentManager", global::ABI.Microsoft.Windows.System.IEnvironmentManagerStaticsMethods.IID);
                }
            }
        }

        public static EnvironmentManager GetForProcess() => global::ABI.Microsoft.Windows.System.IEnvironmentManagerStaticsMethods.GetForProcess(_objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics);

        public static EnvironmentManager GetForUser() => global::ABI.Microsoft.Windows.System.IEnvironmentManagerStaticsMethods.GetForUser(_objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics);

        public static EnvironmentManager GetForMachine() => global::ABI.Microsoft.Windows.System.IEnvironmentManagerStaticsMethods.GetForMachine(_objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics);

        public static bool IsSupported => global::ABI.Microsoft.Windows.System.IEnvironmentManagerStaticsMethods.get_IsSupported(_objRef_global__Microsoft_Windows_System_IEnvironmentManagerStatics);

        public static EnvironmentManager FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<EnvironmentManager>.FromAbi(thisPtr);
        }

        internal EnvironmentManager(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.IID);

        }


        public static bool operator ==(EnvironmentManager x, EnvironmentManager y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(EnvironmentManager x, EnvironmentManager y) => !(x == y);
        public bool Equals(EnvironmentManager other) => this == other;
        public override bool Equals(object obj) => obj is EnvironmentManager that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::System.Collections.Generic.IReadOnlyDictionary<string, string> GetEnvironmentVariables() => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.GetEnvironmentVariables(_objRef_global__Microsoft_Windows_System_IEnvironmentManager);

        public string GetEnvironmentVariable(string name) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.GetEnvironmentVariable(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, name);

        public void SetEnvironmentVariable(string name, string value) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.SetEnvironmentVariable(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, name, value);

        public void AppendToPath(string path) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.AppendToPath(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, path);

        public void RemoveFromPath(string path) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.RemoveFromPath(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, path);

        public void AddExecutableFileExtension(string pathExt) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.AddExecutableFileExtension(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, pathExt);

        public void RemoveExecutableFileExtension(string pathExt) => global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.RemoveExecutableFileExtension(_objRef_global__Microsoft_Windows_System_IEnvironmentManager, pathExt);

        public bool AreChangesTracked => global::ABI.Microsoft.Windows.System.IEnvironmentManager2Methods.get_AreChangesTracked(_objRef_global__Microsoft_Windows_System_IEnvironmentManager2);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::Windows.Foundation.Metadata.ContractVersion(131072u)]
    public enum EnvironmentManagerContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.System")][Guid("D1B239BB-7013-5176-B02A-63477410D986")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.System.IEnvironmentManager))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(EnvironmentManagerContract), 65536u)]
    internal interface IEnvironmentManager
    {
        global::System.Collections.Generic.IReadOnlyDictionary<string, string> GetEnvironmentVariables();
        string GetEnvironmentVariable(string name);
        void SetEnvironmentVariable(string name, string value);
        void AppendToPath(string path);
        void RemoveFromPath(string path);
        void AddExecutableFileExtension(string pathExt);
        void RemoveExecutableFileExtension(string pathExt);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.System")][Guid("CFC0AD51-02B7-57FF-8CA7-E015251737CB")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.System.IEnvironmentManager2))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(EnvironmentManagerContract), 131072u)]
    internal interface IEnvironmentManager2
    {
        bool AreChangesTracked { get; }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.System")][Guid("407B1522-6156-5398-93FD-D6411C35E7B1")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.System.IEnvironmentManagerStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(EnvironmentManagerContract), 65536u)]
    internal interface IEnvironmentManagerStatics
    {
        EnvironmentManager GetForProcess();
        EnvironmentManager GetForUser();
        EnvironmentManager GetForMachine();
        bool IsSupported { get; }
    }
}

#pragma warning disable CA1416
namespace ABI.Microsoft.Windows.System
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct EnvironmentManager
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Windows.System.EnvironmentManager obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Windows.System.EnvironmentManager>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Windows.System.EnvironmentManager obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Windows.System.IEnvironmentManagerMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Windows.System.EnvironmentManager FromAbi(IntPtr thisPtr) => global::Microsoft.Windows.System.EnvironmentManager.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Windows.System.EnvironmentManager obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.MarshalerArray CreateMarshalerArray(global::Microsoft.Windows.System.EnvironmentManager[] array) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.GetAbiArray(box);
        public static unsafe global::Microsoft.Windows.System.EnvironmentManager[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Windows.System.EnvironmentManager[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Windows.System.EnvironmentManager[] array) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Windows.System.EnvironmentManager>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class EnvironmentManagerRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Windows.System.EnvironmentManager(inspectable.ObjRef);
    }
    internal static class IEnvironmentManagerMethods
    {


        internal static unsafe global::System.Collections.Generic.IReadOnlyDictionary<string, string> GetEnvironmentVariables(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_Collections_IMapView_2_String__String.EnsureInitialized();
                return MarshalInterface<global::System.Collections.Generic.IReadOnlyDictionary<string, string>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::System.Collections.Generic.IReadOnlyDictionary<string, string>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe string GetEnvironmentVariable(IObjectReference _obj, string name)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                MarshalString.Pinnable __name = new(name);
                fixed(void* ___name = __name)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalString.GetAbi(ref __name), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return MarshalString.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalString.DisposeAbi(__retval);
            }
        }

        internal static unsafe void SetEnvironmentVariable(IObjectReference _obj, string name, string value)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalString.Pinnable __name = new(name);
            MarshalString.Pinnable __value = new(value);
            fixed(void* ___name = __name, ___value = __value)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, int>**)ThisPtr)[8](ThisPtr, MarshalString.GetAbi(ref __name), MarshalString.GetAbi(ref __value)));
                global::System.GC.KeepAlive(_obj);
            }
        }

        internal static unsafe void AppendToPath(IObjectReference _obj, string path)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalString.Pinnable __path = new(path);
            fixed(void* ___path = __path)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[9](ThisPtr, MarshalString.GetAbi(ref __path)));
                global::System.GC.KeepAlive(_obj);
            }
        }

        internal static unsafe void RemoveFromPath(IObjectReference _obj, string path)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalString.Pinnable __path = new(path);
            fixed(void* ___path = __path)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[10](ThisPtr, MarshalString.GetAbi(ref __path)));
                global::System.GC.KeepAlive(_obj);
            }
        }

        internal static unsafe void AddExecutableFileExtension(IObjectReference _obj, string pathExt)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalString.Pinnable __pathExt = new(pathExt);
            fixed(void* ___pathExt = __pathExt)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[11](ThisPtr, MarshalString.GetAbi(ref __pathExt)));
                global::System.GC.KeepAlive(_obj);
            }
        }

        internal static unsafe void RemoveExecutableFileExtension(IObjectReference _obj, string pathExt)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalString.Pinnable __pathExt = new(pathExt);
            fixed(void* ___pathExt = __pathExt)
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int>**)ThisPtr)[12](ThisPtr, MarshalString.GetAbi(ref __pathExt)));
                global::System.GC.KeepAlive(_obj);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xBB, 0x39, 0xB2, 0xD1, 0x13, 0x70, 0x76, 0x51, 0xB0, 0x2A, 0x63, 0x47, 0x74, 0x10, 0xD9, 0x86 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("D1B239BB-7013-5176-B02A-63477410D986")]
    internal interface IEnvironmentManager : global::Microsoft.Windows.System.IEnvironmentManager
    {
    }
    internal static class IEnvironmentManager2Methods
    {

        internal static unsafe bool get_AreChangesTracked(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval != 0;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x51, 0xAD, 0xC0, 0xCF, 0xB7, 0x2, 0xFF, 0x57, 0x8C, 0xA7, 0xE0, 0x15, 0x25, 0x17, 0x37, 0xCB };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("CFC0AD51-02B7-57FF-8CA7-E015251737CB")]
    internal interface IEnvironmentManager2 : global::Microsoft.Windows.System.IEnvironmentManager2
    {
    }
    internal static class IEnvironmentManagerStaticsMethods
    {


        internal static unsafe global::Microsoft.Windows.System.EnvironmentManager GetForProcess(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Windows.System.EnvironmentManager.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Microsoft.Windows.System.EnvironmentManager.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Windows.System.EnvironmentManager GetForUser(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Windows.System.EnvironmentManager.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Microsoft.Windows.System.EnvironmentManager.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Windows.System.EnvironmentManager GetForMachine(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Windows.System.EnvironmentManager.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Microsoft.Windows.System.EnvironmentManager.DisposeAbi(__retval);
            }
        }
        internal static unsafe bool get_IsSupported(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            byte __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, byte*, int>**)ThisPtr)[9](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval != 0;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x22, 0x15, 0x7B, 0x40, 0x56, 0x61, 0x98, 0x53, 0x93, 0xFD, 0xD6, 0x41, 0x1C, 0x35, 0xE7, 0xB1 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("407B1522-6156-5398-93FD-D6411C35E7B1")]
    internal interface IEnvironmentManagerStatics : global::Microsoft.Windows.System.IEnvironmentManagerStatics
    {
    }
}
#pragma warning restore CA1416
