//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.2.0.241111.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Microsoft.Windows.Security.AccessControl
{
    [global::Windows.Foundation.Metadata.ContractVersion(65536u)]
    public enum AccessControlContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.Security.AccessControl", "struct(Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess;string;u4)")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess))][global::WinRT.WinRTExposedType(typeof(global::WinRT.StructTypeDetails<AppContainerNameAndAccess, global::ABI.Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>))][global::Windows.Foundation.Metadata.ContractVersion(typeof(AccessControlContract), 65536u)]
    public struct AppContainerNameAndAccess: IEquatable<AppContainerNameAndAccess>
    {
        public string appContainerName;
        public uint accessMask;

        public AppContainerNameAndAccess(string _appContainerName, uint _accessMask)
        {
            appContainerName = _appContainerName; accessMask = _accessMask; 
        }

        public static bool operator ==(AppContainerNameAndAccess x, AppContainerNameAndAccess y) => x.appContainerName == y.appContainerName && x.accessMask == y.accessMask;
        public static bool operator !=(AppContainerNameAndAccess x, AppContainerNameAndAccess y) => !(x == y);
        public bool Equals(AppContainerNameAndAccess other) => this == other;
        public override bool Equals(object obj) => obj is AppContainerNameAndAccess that && this == that;
        public override int GetHashCode() => appContainerName.GetHashCode() ^ accessMask.GetHashCode();
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.Security.AccessControl")][Guid("14FA9E8D-59F0-5017-852F-3AE24FD5EBB1")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.Security.AccessControl.ISecurityDescriptorHelpersStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(AccessControlContract), 65536u)]
    internal interface ISecurityDescriptorHelpersStatics
    {
        string GetSddlForAppContainerNames(AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask);
        byte[] GetSecurityDescriptorBytesFromAppContainerNames(AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.Security.AccessControl")][global::Windows.Foundation.Metadata.ContractVersion(typeof(AccessControlContract), 65536u)]
    public static class SecurityDescriptorHelpers
    {

        public static I As<I>() => ActivationFactory.Get("Microsoft.Windows.Security.AccessControl.SecurityDescriptorHelpers").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics;
        private static IObjectReference _objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics = ActivationFactory.Get("Microsoft.Windows.Security.AccessControl.SecurityDescriptorHelpers", global::ABI.Microsoft.Windows.Security.AccessControl.ISecurityDescriptorHelpersStaticsMethods.IID);
                }
            }
        }

        public static string GetSddlForAppContainerNames(AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask) => global::ABI.Microsoft.Windows.Security.AccessControl.ISecurityDescriptorHelpersStaticsMethods.GetSddlForAppContainerNames(_objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics, accessRequests, principalStringSid, principalAccessMask);

        public static byte[] GetSecurityDescriptorBytesFromAppContainerNames(AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask) => global::ABI.Microsoft.Windows.Security.AccessControl.ISecurityDescriptorHelpersStaticsMethods.GetSecurityDescriptorBytesFromAppContainerNames(_objRef_global__Microsoft_Windows_Security_AccessControl_ISecurityDescriptorHelpersStatics, accessRequests, principalStringSid, principalAccessMask);
    }
}

#pragma warning disable CA1416
namespace ABI.Microsoft.Windows.Security.AccessControl
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct AppContainerNameAndAccess
    {
        public IntPtr appContainerName;
        public uint accessMask;

        public struct Marshaler
        {
            public MarshalString _appContainerName;
            public AppContainerNameAndAccess __abi;
            public void Dispose()
            {
                MarshalString.DisposeMarshaler(_appContainerName);
            }
        }

        public static Marshaler CreateMarshaler(global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess arg)
        {
            var m = new Marshaler();
            bool success = false;
            try
            {
                m._appContainerName = MarshalString.CreateMarshaler(arg.appContainerName);
                m.__abi = new AppContainerNameAndAccess()
                {
                    appContainerName = MarshalString.GetAbi(m._appContainerName)
                    , accessMask = arg.accessMask
                };
                success = true;
                return m;
            }
            finally
            {
                if (!success)
                {
                    m.Dispose();
                }
            }
        }

        public static AppContainerNameAndAccess GetAbi(Marshaler m) => m.__abi;

        public static global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess FromAbi(AppContainerNameAndAccess arg)
        {
            return new global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess()
            {
                appContainerName = MarshalString.FromAbi(arg.appContainerName)
                , accessMask = arg.accessMask
            };
        }

        public static AppContainerNameAndAccess FromManaged(global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess arg)
        {
            return new AppContainerNameAndAccess()
            {
                appContainerName = MarshalString.FromManaged(arg.appContainerName)
                , accessMask = arg.accessMask
            };
        }

        public static unsafe void CopyAbi(Marshaler arg, IntPtr dest) => 
            *(AppContainerNameAndAccess*)dest.ToPointer() = GetAbi(arg);

        public static unsafe void CopyManaged(global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess arg, IntPtr dest) =>
            *(AppContainerNameAndAccess*)dest.ToPointer() = FromManaged(arg);

        public static void DisposeMarshaler(Marshaler m) => m.Dispose();

        public static void DisposeAbi(AppContainerNameAndAccess abi)
        {
            MarshalString.DisposeAbi(abi.appContainerName);
        }
    }
    internal static class ISecurityDescriptorHelpersStaticsMethods
    {


        internal static unsafe string GetSddlForAppContainerNames(IObjectReference _obj, global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.MarshalerArray __accessRequests = default;
            int __accessRequests_length = default;
            IntPtr __accessRequests_data = default;
            IntPtr __retval = default;
            try
            {
                __accessRequests = MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.CreateMarshalerArray(accessRequests);
                (__accessRequests_length, __accessRequests_data) = MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.GetAbiArray(__accessRequests);
                MarshalString.Pinnable __principalStringSid = new(principalStringSid);
                fixed(void* ___principalStringSid = __principalStringSid)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, __accessRequests_length, __accessRequests_data, MarshalString.GetAbi(ref __principalStringSid), principalAccessMask, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return MarshalString.FromAbi(__retval);
                }
            }
            finally
            {
                MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.DisposeMarshalerArray(__accessRequests);
                MarshalString.DisposeAbi(__retval);
            }
        }

        internal static unsafe byte[] GetSecurityDescriptorBytesFromAppContainerNames(IObjectReference _obj, global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess[] accessRequests, string principalStringSid, uint principalAccessMask)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.MarshalerArray __accessRequests = default;
            int __accessRequests_length = default;
            IntPtr __accessRequests_data = default;
            int __retval_length = default;
            IntPtr __retval_data = default;
            try
            {
                __accessRequests = MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.CreateMarshalerArray(accessRequests);
                (__accessRequests_length, __accessRequests_data) = MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.GetAbiArray(__accessRequests);
                MarshalString.Pinnable __principalStringSid = new(principalStringSid);
                fixed(void* ___principalStringSid = __principalStringSid)
                {
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, IntPtr, uint, int*, IntPtr*, int>**)ThisPtr)[7](ThisPtr, __accessRequests_length, __accessRequests_data, MarshalString.GetAbi(ref __principalStringSid), principalAccessMask, &__retval_length, &__retval_data));
                    global::System.GC.KeepAlive(_obj);
                    return MarshalBlittable<byte>.FromAbiArray((__retval_length, __retval_data));
                }
            }
            finally
            {
                MarshalNonBlittable<global::Microsoft.Windows.Security.AccessControl.AppContainerNameAndAccess>.DisposeMarshalerArray(__accessRequests);
                MarshalBlittable<byte>.DisposeAbiArray((__retval_length, __retval_data));
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x8D, 0x9E, 0xFA, 0x14, 0xF0, 0x59, 0x17, 0x50, 0x85, 0x2F, 0x3A, 0xE2, 0x4F, 0xD5, 0xEB, 0xB1 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("14FA9E8D-59F0-5017-852F-3AE24FD5EBB1")]
    internal interface ISecurityDescriptorHelpersStatics : global::Microsoft.Windows.Security.AccessControl.ISecurityDescriptorHelpersStatics
    {
    }
}
#pragma warning restore CA1416
