//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.2.0.241111.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Microsoft.Graphics.Imaging
{
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("D8D9C801-5B32-54B6-A6E2-7384C6B822ED")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageBuffer))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageBuffer
    {
        global::Windows.Graphics.Imaging.SoftwareBitmap CreateSoftwareBitmap();
        void CopyToBuffer(byte[] values);
        global::Windows.Storage.Streams.IBuffer Buffer { get; }
        uint BufferLength { get; }
        uint Height { get; }
        PixelFormat PixelFormat { get; }
        uint Width { get; }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("D1F288FD-37F1-5490-80B7-A2CA953C9FE5")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageBufferFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageBufferFactory
    {
        ImageBuffer CreateInstance(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("E2DA1565-9F5F-5A92-B58C-0099643A289A")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageBufferStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageBufferStatics
    {
        ImageBuffer CreateCopyFromBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap);
        ImageBuffer CreateBufferAttachedToBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("21C83045-1161-5A0F-AFBF-7330D0D74B97")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageBufferStatics2))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 131072u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageBufferStatics2
    {
        ImageBuffer CreateFromBuffer(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height);
        ImageBuffer CreateFromBufferWithStride(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height, uint stride);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("1ED9427D-58E6-5BEC-9708-FAC1BE8A5AAE")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractor))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectExtractor
    {
        global::Windows.Graphics.Imaging.SoftwareBitmap GetSoftwareBitmapObjectMask(ImageObjectExtractorHint hint);
        ImageBuffer GetImageBufferObjectMask(ImageObjectExtractorHint hint);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("FAF8F38A-350F-5B4A-9E20-7A1812D48959")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHint))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectExtractorHint
    {
        global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> ExcludePoints { get; }
        global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> IncludePoints { get; }
        global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.RectInt32> IncludeRects { get; }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("CD873E40-EF5A-5C3A-9297-25BA3A066872")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectExtractorHintFactory
    {
        ImageObjectExtractorHint CreateInstance(global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32> includeRects, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> includePoints, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> excludePoints);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("D33E1BDE-FC42-53D6-82FF-7ADA45C9319A")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectExtractorStatics
    {
        global::Windows.Foundation.IAsyncOperation<ImageObjectExtractor> CreateWithSoftwareBitmapAsync(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap);
        global::Windows.Foundation.IAsyncOperation<ImageObjectExtractor> CreateWithImageBufferAsync(ImageBuffer imageBuffer);
        global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState();
        global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync();
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("BF25B5F9-D8B0-5159-9E93-81ADB0B28AEA")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemover))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectRemoverContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectRemover
    {
        global::Windows.Graphics.Imaging.SoftwareBitmap RemoveFromSoftwareBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmapMask);
        ImageBuffer RemoveFromImageBuffer(ImageBuffer imageBuffer, ImageBuffer imageBufferMask);
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("DD4A80B1-032A-58F3-9A4D-5C317A874A03")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectRemoverContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageObjectRemoverStatics
    {
        global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState();
        global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync();
        global::Windows.Foundation.IAsyncOperation<ImageObjectRemover> CreateAsync();
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("22103A1E-0B07-5645-B1F1-FFC3E854FD5B")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageScaler))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageScalerContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageScaler
    {
        global::Windows.Graphics.Imaging.SoftwareBitmap ScaleSoftwareBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, int width, int height);
        ImageBuffer ScaleImageBuffer(ImageBuffer imageBuffer, int width, int height);
        int MaxSupportedScaleFactor { get; }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][Guid("026772DF-1415-5F7A-BD62-73EEC08EFFE6")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.IImageScalerStatics))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageScalerContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IImageScalerStatics
    {
        global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState();
        global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync();
        global::Windows.Foundation.IAsyncOperation<ImageScaler> CreateAsync();
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.ImageBuffer))]
    [global::ABI.Microsoft.Graphics.Imaging.ImageBufferRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IImageBuffer))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class ImageBuffer : global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<ImageBuffer>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageBuffer => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        private static class _IImageBufferFactoryMethods
        {
            public static unsafe IntPtr CreateInstance(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height)
            {
                var ThisPtr = _obj.ThisPtr;

                ObjectReferenceValue __buffer = default;
                IntPtr __retval = default;
                try
                {
                    __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, PixelFormat, uint, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), pixelFormat, width, height, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return __retval;
                }
                finally
                {
                    MarshalInspectable<object>.DisposeMarshaler(__buffer);
                }
            }
        }

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferFactory;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageBufferFactory
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferFactory = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageBuffer", global::ABI.Microsoft.Graphics.Imaging.IImageBufferFactoryMethods.IID);
                }
            }
        }

        public ImageBuffer(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height) 
        { 
        IntPtr ptr = (_IImageBufferFactoryMethods.CreateInstance(_objRef_global__Microsoft_Graphics_Imaging_IImageBufferFactory, buffer, pixelFormat, width, height)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static I As<I>() => ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageBuffer").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageBuffer", global::ABI.Microsoft.Graphics.Imaging.IImageBufferStaticsMethods.IID);
                }
            }
        }

        public static ImageBuffer CreateCopyFromBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap) => global::ABI.Microsoft.Graphics.Imaging.IImageBufferStaticsMethods.CreateCopyFromBitmap(_objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics, softwareBitmap);

        public static ImageBuffer CreateBufferAttachedToBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap) => global::ABI.Microsoft.Graphics.Imaging.IImageBufferStaticsMethods.CreateBufferAttachedToBitmap(_objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics, softwareBitmap);

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2 = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageBuffer", global::ABI.Microsoft.Graphics.Imaging.IImageBufferStatics2Methods.IID);
                }
            }
        }

        public static ImageBuffer CreateFromBuffer(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height) => global::ABI.Microsoft.Graphics.Imaging.IImageBufferStatics2Methods.CreateFromBuffer(_objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2, buffer, pixelFormat, width, height);

        public static ImageBuffer CreateFromBufferWithStride(global::Windows.Storage.Streams.IBuffer buffer, PixelFormat pixelFormat, uint width, uint height, uint stride) => global::ABI.Microsoft.Graphics.Imaging.IImageBufferStatics2Methods.CreateFromBufferWithStride(_objRef_global__Microsoft_Graphics_Imaging_IImageBufferStatics2, buffer, pixelFormat, width, height, stride);

        public static ImageBuffer FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<ImageBuffer>.FromAbi(thisPtr);
        }

        internal ImageBuffer(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.IID);

        }


        public static bool operator ==(ImageBuffer x, ImageBuffer y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(ImageBuffer x, ImageBuffer y) => !(x == y);
        public bool Equals(ImageBuffer other) => this == other;
        public override bool Equals(object obj) => obj is ImageBuffer that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Graphics.Imaging.SoftwareBitmap CreateSoftwareBitmap() => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.CreateSoftwareBitmap(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        public void CopyToBuffer(byte[] values) => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.CopyToBuffer(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer, values);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public global::Windows.Storage.Streams.IBuffer Buffer => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.get_Buffer(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        public uint BufferLength => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.get_BufferLength(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        public uint Height => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.get_Height(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        public PixelFormat PixelFormat => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.get_PixelFormat(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        public uint Width => global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.get_Width(_objRef_global__Microsoft_Graphics_Imaging_IImageBuffer);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::Windows.Foundation.Metadata.ContractVersion(131072u)]
    public enum ImageBufferContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractor))]
    [global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IImageObjectExtractor))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class ImageObjectExtractor : global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<ImageObjectExtractor>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractor => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static I As<I>() => ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageObjectExtractor").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageObjectExtractor", global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStaticsMethods.IID);
                }
            }
        }

        public static global::Windows.Foundation.IAsyncOperation<ImageObjectExtractor> CreateWithSoftwareBitmapAsync(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStaticsMethods.CreateWithSoftwareBitmapAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics, softwareBitmap);

        public static global::Windows.Foundation.IAsyncOperation<ImageObjectExtractor> CreateWithImageBufferAsync(ImageBuffer imageBuffer) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStaticsMethods.CreateWithImageBufferAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics, imageBuffer);

        public static global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState() => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStaticsMethods.GetReadyState(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics);

        public static global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync() => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorStaticsMethods.EnsureReadyAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorStatics);

        public static ImageObjectExtractor FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<ImageObjectExtractor>.FromAbi(thisPtr);
        }

        internal ImageObjectExtractor(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorMethods.IID);

        }


        public static bool operator ==(ImageObjectExtractor x, ImageObjectExtractor y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(ImageObjectExtractor x, ImageObjectExtractor y) => !(x == y);
        public bool Equals(ImageObjectExtractor other) => this == other;
        public override bool Equals(object obj) => obj is ImageObjectExtractor that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Graphics.Imaging.SoftwareBitmap GetSoftwareBitmapObjectMask(ImageObjectExtractorHint hint) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorMethods.GetSoftwareBitmapObjectMask(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractor, hint);

        public ImageBuffer GetImageBufferObjectMask(ImageObjectExtractorHint hint) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorMethods.GetImageBufferObjectMask(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractor, hint);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::Windows.Foundation.Metadata.ContractVersion(65536u)]
    public enum ImageObjectExtractorContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHint))]
    [global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHintRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IImageObjectExtractorHint))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectExtractorContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class ImageObjectExtractorHint : global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<ImageObjectExtractorHint>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHint => _inner;


        private static class _IImageObjectExtractorHintFactoryMethods
        {
            public static unsafe IntPtr CreateInstance(IObjectReference _obj, global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32> includeRects, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> includePoints, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> excludePoints)
            {
                var ThisPtr = _obj.ThisPtr;

                ObjectReferenceValue __includeRects = default;
                ObjectReferenceValue __includePoints = default;
                ObjectReferenceValue __excludePoints = default;
                IntPtr __retval = default;
                try
                {
                    __includeRects = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32>>.CreateMarshaler2(includeRects, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.RectInt32>.IID);
                    __includePoints = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32>>.CreateMarshaler2(includePoints, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.PointInt32>.IID);
                    __excludePoints = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32>>.CreateMarshaler2(excludePoints, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.PointInt32>.IID);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__includeRects), MarshalInspectable<object>.GetAbi(__includePoints), MarshalInspectable<object>.GetAbi(__excludePoints), &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return __retval;
                }
                finally
                {
                    MarshalInspectable<object>.DisposeMarshaler(__includeRects);
                    MarshalInspectable<object>.DisposeMarshaler(__includePoints);
                    MarshalInspectable<object>.DisposeMarshaler(__excludePoints);
                }
            }
        }

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageObjectExtractorHint", global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintFactoryMethods.IID);
                }
            }
        }

        public ImageObjectExtractorHint(global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32> includeRects, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> includePoints, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> excludePoints) 
        { 
        IntPtr ptr = (_IImageObjectExtractorHintFactoryMethods.CreateInstance(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHintFactory, includeRects, includePoints, excludePoints)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static ImageObjectExtractorHint FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<ImageObjectExtractorHint>.FromAbi(thisPtr);
        }

        internal ImageObjectExtractorHint(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.IID);

        }


        public static bool operator ==(ImageObjectExtractorHint x, ImageObjectExtractorHint y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(ImageObjectExtractorHint x, ImageObjectExtractorHint y) => !(x == y);
        public bool Equals(ImageObjectExtractorHint other) => this == other;
        public override bool Equals(object obj) => obj is ImageObjectExtractorHint that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> ExcludePoints => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.get_ExcludePoints(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHint);

        public global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> IncludePoints => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.get_IncludePoints(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHint);

        public global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.RectInt32> IncludeRects => global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.get_IncludeRects(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectExtractorHint);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.ImageObjectRemover))]
    [global::ABI.Microsoft.Graphics.Imaging.ImageObjectRemoverRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IImageObjectRemover))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageObjectRemoverContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class ImageObjectRemover : global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<ImageObjectRemover>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemover => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static I As<I>() => ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageObjectRemover").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageObjectRemover", global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverStaticsMethods.IID);
                }
            }
        }

        public static global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState() => global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverStaticsMethods.GetReadyState(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics);

        public static global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync() => global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverStaticsMethods.EnsureReadyAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics);

        public static global::Windows.Foundation.IAsyncOperation<ImageObjectRemover> CreateAsync() => global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverStaticsMethods.CreateAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemoverStatics);

        public static ImageObjectRemover FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<ImageObjectRemover>.FromAbi(thisPtr);
        }

        internal ImageObjectRemover(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverMethods.IID);

        }


        public static bool operator ==(ImageObjectRemover x, ImageObjectRemover y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(ImageObjectRemover x, ImageObjectRemover y) => !(x == y);
        public bool Equals(ImageObjectRemover other) => this == other;
        public override bool Equals(object obj) => obj is ImageObjectRemover that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Graphics.Imaging.SoftwareBitmap RemoveFromSoftwareBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmapMask) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverMethods.RemoveFromSoftwareBitmap(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemover, softwareBitmap, softwareBitmapMask);

        public ImageBuffer RemoveFromImageBuffer(ImageBuffer imageBuffer, ImageBuffer imageBufferMask) => global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverMethods.RemoveFromImageBuffer(_objRef_global__Microsoft_Graphics_Imaging_IImageObjectRemover, imageBuffer, imageBufferMask);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::Windows.Foundation.Metadata.ContractVersion(65536u)]
    public enum ImageObjectRemoverContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Graphics.Imaging.ImageScaler))]
    [global::ABI.Microsoft.Graphics.Imaging.ImageScalerRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IImageScaler))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageScalerContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class ImageScaler : global::System.IDisposable, global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<ImageScaler>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageScaler => _inner;
        private volatile IObjectReference ___objRef_global__System_IDisposable;
        private IObjectReference Make___objRef_global__System_IDisposable()
        {
            global::System.Threading.Interlocked.CompareExchange(ref ___objRef_global__System_IDisposable, ((IWinRTObject)this).NativeObject.As<IUnknownVftbl>(global::ABI.System.IDisposableMethods.IID), null);
            return ___objRef_global__System_IDisposable;
        }
        private IObjectReference _objRef_global__System_IDisposable => ___objRef_global__System_IDisposable ?? Make___objRef_global__System_IDisposable();



        public static I As<I>() => ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageScaler").AsInterface<I>();

        private static volatile IObjectReference ___objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics;
        private static IObjectReference _objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics = ActivationFactory.Get("Microsoft.Graphics.Imaging.ImageScaler", global::ABI.Microsoft.Graphics.Imaging.IImageScalerStaticsMethods.IID);
                }
            }
        }

        public static global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState() => global::ABI.Microsoft.Graphics.Imaging.IImageScalerStaticsMethods.GetReadyState(_objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics);

        public static global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync() => global::ABI.Microsoft.Graphics.Imaging.IImageScalerStaticsMethods.EnsureReadyAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics);

        public static global::Windows.Foundation.IAsyncOperation<ImageScaler> CreateAsync() => global::ABI.Microsoft.Graphics.Imaging.IImageScalerStaticsMethods.CreateAsync(_objRef_global__Microsoft_Graphics_Imaging_IImageScalerStatics);

        public static ImageScaler FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<ImageScaler>.FromAbi(thisPtr);
        }

        internal ImageScaler(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.IID);

        }


        public static bool operator ==(ImageScaler x, ImageScaler y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(ImageScaler x, ImageScaler y) => !(x == y);
        public bool Equals(ImageScaler other) => this == other;
        public override bool Equals(object obj) => obj is ImageScaler that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public global::Windows.Graphics.Imaging.SoftwareBitmap ScaleSoftwareBitmap(global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, int width, int height) => global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.ScaleSoftwareBitmap(_objRef_global__Microsoft_Graphics_Imaging_IImageScaler, softwareBitmap, width, height);

        public ImageBuffer ScaleImageBuffer(ImageBuffer imageBuffer, int width, int height) => global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.ScaleImageBuffer(_objRef_global__Microsoft_Graphics_Imaging_IImageScaler, imageBuffer, width, height);

        public void Dispose() => global::ABI.System.IDisposableMethods.Dispose(_objRef_global__System_IDisposable);

        public int MaxSupportedScaleFactor => global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.get_MaxSupportedScaleFactor(_objRef_global__Microsoft_Graphics_Imaging_IImageScaler);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::Windows.Foundation.Metadata.ContractVersion(65536u)]
    public enum ImageScalerContract
    {
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Graphics.Imaging")][global::WinRT.WinRTExposedType(typeof(global::WinRT.EnumTypeDetails<PixelFormat>))][global::Windows.Foundation.Metadata.ContractVersion(typeof(ImageBufferContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public enum PixelFormat : int
    {
        Undefined = unchecked((int)0),
        Rgb24 = unchecked((int)0x1),
        Argb32 = unchecked((int)0x2),
        Rgba32 = unchecked((int)0x3),
        Bgra32 = unchecked((int)0x4),
        Gray8 = unchecked((int)0x5),
    }
}

#pragma warning disable CA1416
namespace ABI.Microsoft.Graphics.Imaging
{
    internal static class IImageBufferMethods
    {


        internal static unsafe global::Windows.Graphics.Imaging.SoftwareBitmap CreateSoftwareBitmap(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.FromAbi(__retval);
            }
            finally
            {
                global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.DisposeAbi(__retval);
            }
        }

        internal static unsafe void CopyToBuffer(IObjectReference _obj, byte[] values)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<byte>.MarshalerArray __values = default;
            int __values_length = default;
            IntPtr __values_data = default;
            try
            {
                __values = MarshalBlittable<byte>.CreateMarshalerArray(values);
                (__values_length, __values_data) = MarshalBlittable<byte>.GetAbiArray(__values);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[12](ThisPtr, __values_length, __values_data));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalBlittable<byte>.DisposeMarshalerArray(__values);
            }
        }
        internal static unsafe global::Windows.Storage.Streams.IBuffer get_Buffer(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                return MarshalInterface<global::Windows.Storage.Streams.IBuffer>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Storage.Streams.IBuffer>.DisposeAbi(__retval);
            }
        }

        internal static unsafe uint get_BufferLength(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[11](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe uint get_Height(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[9](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.PixelFormat get_PixelFormat(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Microsoft.Graphics.Imaging.PixelFormat __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Microsoft.Graphics.Imaging.PixelFormat*, int>**)ThisPtr)[8](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe uint get_Width(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[10](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x1, 0xC8, 0xD9, 0xD8, 0x32, 0x5B, 0xB6, 0x54, 0xA6, 0xE2, 0x73, 0x84, 0xC6, 0xB8, 0x22, 0xED };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("D8D9C801-5B32-54B6-A6E2-7384C6B822ED")]
    internal interface IImageBuffer : global::Microsoft.Graphics.Imaging.IImageBuffer
    {
    }
    internal static class IImageBufferFactoryMethods
    {


        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer CreateInstance(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, global::Microsoft.Graphics.Imaging.PixelFormat pixelFormat, uint width, uint height)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Microsoft.Graphics.Imaging.PixelFormat, uint, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), pixelFormat, width, height, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xFD, 0x88, 0xF2, 0xD1, 0xF1, 0x37, 0x90, 0x54, 0x80, 0xB7, 0xA2, 0xCA, 0x95, 0x3C, 0x9F, 0xE5 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("D1F288FD-37F1-5490-80B7-A2CA953C9FE5")]
    internal interface IImageBufferFactory : global::Microsoft.Graphics.Imaging.IImageBufferFactory
    {
    }
    internal static class IImageBufferStaticsMethods
    {


        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer CreateCopyFromBitmap(IObjectReference _obj, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __softwareBitmap = default;
            IntPtr __retval = default;
            try
            {
                __softwareBitmap = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmap);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__softwareBitmap), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmap);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer CreateBufferAttachedToBitmap(IObjectReference _obj, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __softwareBitmap = default;
            IntPtr __retval = default;
            try
            {
                __softwareBitmap = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmap);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__softwareBitmap), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmap);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x65, 0x15, 0xDA, 0xE2, 0x5F, 0x9F, 0x92, 0x5A, 0xB5, 0x8C, 0x0, 0x99, 0x64, 0x3A, 0x28, 0x9A };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("E2DA1565-9F5F-5A92-B58C-0099643A289A")]
    internal interface IImageBufferStatics : global::Microsoft.Graphics.Imaging.IImageBufferStatics
    {
    }
    internal static class IImageBufferStatics2Methods
    {


        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer CreateFromBuffer(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, global::Microsoft.Graphics.Imaging.PixelFormat pixelFormat, uint width, uint height)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Microsoft.Graphics.Imaging.PixelFormat, uint, uint, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), pixelFormat, width, height, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer CreateFromBufferWithStride(IObjectReference _obj, global::Windows.Storage.Streams.IBuffer buffer, global::Microsoft.Graphics.Imaging.PixelFormat pixelFormat, uint width, uint height, uint stride)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __buffer = default;
            IntPtr __retval = default;
            try
            {
                __buffer = MarshalInterface<global::Windows.Storage.Streams.IBuffer>.CreateMarshaler2(buffer, global::ABI.Windows.Storage.Streams.IBufferMethods.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, global::Microsoft.Graphics.Imaging.PixelFormat, uint, uint, uint, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__buffer), pixelFormat, width, height, stride, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__buffer);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x45, 0x30, 0xC8, 0x21, 0x61, 0x11, 0xF, 0x5A, 0xAF, 0xBF, 0x73, 0x30, 0xD0, 0xD7, 0x4B, 0x97 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("21C83045-1161-5A0F-AFBF-7330D0D74B97")]
    internal interface IImageBufferStatics2 : global::Microsoft.Graphics.Imaging.IImageBufferStatics2
    {
    }
    internal static class IImageObjectExtractorMethods
    {


        internal static unsafe global::Windows.Graphics.Imaging.SoftwareBitmap GetSoftwareBitmapObjectMask(IObjectReference _obj, global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint hint)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __hint = default;
            IntPtr __retval = default;
            try
            {
                __hint = global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHint.CreateMarshaler2(hint);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__hint), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__hint);
                global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer GetImageBufferObjectMask(IObjectReference _obj, global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint hint)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __hint = default;
            IntPtr __retval = default;
            try
            {
                __hint = global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHint.CreateMarshaler2(hint);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__hint), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__hint);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x7D, 0x42, 0xD9, 0x1E, 0xE6, 0x58, 0xEC, 0x5B, 0x97, 0x8, 0xFA, 0xC1, 0xBE, 0x8A, 0x5A, 0xAE };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("1ED9427D-58E6-5BEC-9708-FAC1BE8A5AAE")]
    internal interface IImageObjectExtractor : global::Microsoft.Graphics.Imaging.IImageObjectExtractor
    {
    }
    internal static class IImageObjectExtractorHintMethods
    {

        internal static unsafe global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> get_ExcludePoints(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_Collections_IVectorView_1_Windows_Graphics_PointInt32.EnsureInitialized();
                return MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32> get_IncludePoints(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_Collections_IVectorView_1_Windows_Graphics_PointInt32.EnsureInitialized();
                return MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.PointInt32>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.RectInt32> get_IncludeRects(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_Collections_IVectorView_1_Windows_Graphics_RectInt32.EnsureInitialized();
                return MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.RectInt32>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::System.Collections.Generic.IReadOnlyList<global::Windows.Graphics.RectInt32>>.DisposeAbi(__retval);
            }
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x8A, 0xF3, 0xF8, 0xFA, 0xF, 0x35, 0x4A, 0x5B, 0x9E, 0x20, 0x7A, 0x18, 0x12, 0xD4, 0x89, 0x59 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("FAF8F38A-350F-5B4A-9E20-7A1812D48959")]
    internal interface IImageObjectExtractorHint : global::Microsoft.Graphics.Imaging.IImageObjectExtractorHint
    {
    }
    internal static class IImageObjectExtractorHintFactoryMethods
    {


        internal static unsafe global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint CreateInstance(IObjectReference _obj, global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32> includeRects, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> includePoints, global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32> excludePoints)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __includeRects = default;
            ObjectReferenceValue __includePoints = default;
            ObjectReferenceValue __excludePoints = default;
            IntPtr __retval = default;
            try
            {
                __includeRects = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.RectInt32>>.CreateMarshaler2(includeRects, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.RectInt32>.IID);
                __includePoints = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32>>.CreateMarshaler2(includePoints, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.PointInt32>.IID);
                __excludePoints = MarshalInterface<global::System.Collections.Generic.IList<global::Windows.Graphics.PointInt32>>.CreateMarshaler2(excludePoints, global::ABI.System.Collections.Generic.IListMethods<global::Windows.Graphics.PointInt32>.IID);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__includeRects), MarshalInspectable<object>.GetAbi(__includePoints), MarshalInspectable<object>.GetAbi(__excludePoints), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHint.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__includeRects);
                MarshalInspectable<object>.DisposeMarshaler(__includePoints);
                MarshalInspectable<object>.DisposeMarshaler(__excludePoints);
                global::ABI.Microsoft.Graphics.Imaging.ImageObjectExtractorHint.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x40, 0x3E, 0x87, 0xCD, 0x5A, 0xEF, 0x3A, 0x5C, 0x92, 0x97, 0x25, 0xBA, 0x3A, 0x6, 0x68, 0x72 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("CD873E40-EF5A-5C3A-9297-25BA3A066872")]
    internal interface IImageObjectExtractorHintFactory : global::Microsoft.Graphics.Imaging.IImageObjectExtractorHintFactory
    {
    }
    internal static class IImageObjectExtractorStaticsMethods
    {


        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor> CreateWithSoftwareBitmapAsync(IObjectReference _obj, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __softwareBitmap = default;
            IntPtr __retval = default;
            try
            {
                __softwareBitmap = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmap);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__softwareBitmap), &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Microsoft_Graphics_Imaging_ImageObjectExtractor.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmap);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor> CreateWithImageBufferAsync(IObjectReference _obj, global::Microsoft.Graphics.Imaging.ImageBuffer imageBuffer)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __imageBuffer = default;
            IntPtr __retval = default;
            try
            {
                __imageBuffer = global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.CreateMarshaler2(imageBuffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__imageBuffer), &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Microsoft_Graphics_Imaging_ImageObjectExtractor.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__imageBuffer);
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Microsoft.Windows.AI.AIFeatureReadyState __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Microsoft.Windows.AI.AIFeatureReadyState*, int>**)ThisPtr)[8](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[9](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_Microsoft_Windows_AI_AIFeatureReadyResult__Double.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xDE, 0x1B, 0x3E, 0xD3, 0x42, 0xFC, 0xD6, 0x53, 0x82, 0xFF, 0x7A, 0xDA, 0x45, 0xC9, 0x31, 0x9A };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("D33E1BDE-FC42-53D6-82FF-7ADA45C9319A")]
    internal interface IImageObjectExtractorStatics : global::Microsoft.Graphics.Imaging.IImageObjectExtractorStatics
    {
    }
    internal static class IImageObjectRemoverMethods
    {


        internal static unsafe global::Windows.Graphics.Imaging.SoftwareBitmap RemoveFromSoftwareBitmap(IObjectReference _obj, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmapMask)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __softwareBitmap = default;
            ObjectReferenceValue __softwareBitmapMask = default;
            IntPtr __retval = default;
            try
            {
                __softwareBitmap = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmap);
                __softwareBitmapMask = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmapMask);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__softwareBitmap), MarshalInspectable<object>.GetAbi(__softwareBitmapMask), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmap);
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmapMask);
                global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer RemoveFromImageBuffer(IObjectReference _obj, global::Microsoft.Graphics.Imaging.ImageBuffer imageBuffer, global::Microsoft.Graphics.Imaging.ImageBuffer imageBufferMask)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __imageBuffer = default;
            ObjectReferenceValue __imageBufferMask = default;
            IntPtr __retval = default;
            try
            {
                __imageBuffer = global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.CreateMarshaler2(imageBuffer);
                __imageBufferMask = global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.CreateMarshaler2(imageBufferMask);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__imageBuffer), MarshalInspectable<object>.GetAbi(__imageBufferMask), &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__imageBuffer);
                MarshalInspectable<object>.DisposeMarshaler(__imageBufferMask);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xF9, 0xB5, 0x25, 0xBF, 0xB0, 0xD8, 0x59, 0x51, 0x9E, 0x93, 0x81, 0xAD, 0xB0, 0xB2, 0x8A, 0xEA };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("BF25B5F9-D8B0-5159-9E93-81ADB0B28AEA")]
    internal interface IImageObjectRemover : global::Microsoft.Graphics.Imaging.IImageObjectRemover
    {
    }
    internal static class IImageObjectRemoverStaticsMethods
    {


        internal static unsafe global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Microsoft.Windows.AI.AIFeatureReadyState __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Microsoft.Windows.AI.AIFeatureReadyState*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_Microsoft_Windows_AI_AIFeatureReadyResult__Double.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectRemover> CreateAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Microsoft_Graphics_Imaging_ImageObjectRemover.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectRemover>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageObjectRemover>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xB1, 0x80, 0x4A, 0xDD, 0x2A, 0x3, 0xF3, 0x58, 0x9A, 0x4D, 0x5C, 0x31, 0x7A, 0x87, 0x4A, 0x3 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("DD4A80B1-032A-58F3-9A4D-5C317A874A03")]
    internal interface IImageObjectRemoverStatics : global::Microsoft.Graphics.Imaging.IImageObjectRemoverStatics
    {
    }
    internal static class IImageScalerMethods
    {


        internal static unsafe global::Windows.Graphics.Imaging.SoftwareBitmap ScaleSoftwareBitmap(IObjectReference _obj, global::Windows.Graphics.Imaging.SoftwareBitmap softwareBitmap, int width, int height)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __softwareBitmap = default;
            IntPtr __retval = default;
            try
            {
                __softwareBitmap = global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.CreateMarshaler2(softwareBitmap);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int, int, IntPtr*, int>**)ThisPtr)[6](ThisPtr, MarshalInspectable<object>.GetAbi(__softwareBitmap), width, height, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__softwareBitmap);
                global::ABI.Windows.Graphics.Imaging.SoftwareBitmap.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer ScaleImageBuffer(IObjectReference _obj, global::Microsoft.Graphics.Imaging.ImageBuffer imageBuffer, int width, int height)
        {
            var ThisPtr = _obj.ThisPtr;

            ObjectReferenceValue __imageBuffer = default;
            IntPtr __retval = default;
            try
            {
                __imageBuffer = global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.CreateMarshaler2(imageBuffer);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr, int, int, IntPtr*, int>**)ThisPtr)[7](ThisPtr, MarshalInspectable<object>.GetAbi(__imageBuffer), width, height, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(__retval);
            }
            finally
            {
                MarshalInspectable<object>.DisposeMarshaler(__imageBuffer);
                global::ABI.Microsoft.Graphics.Imaging.ImageBuffer.DisposeAbi(__retval);
            }
        }
        internal static unsafe int get_MaxSupportedScaleFactor(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            int __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int*, int>**)ThisPtr)[8](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0x1E, 0x3A, 0x10, 0x22, 0x7, 0xB, 0x45, 0x56, 0xB1, 0xF1, 0xFF, 0xC3, 0xE8, 0x54, 0xFD, 0x5B };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("22103A1E-0B07-5645-B1F1-FFC3E854FD5B")]
    internal interface IImageScaler : global::Microsoft.Graphics.Imaging.IImageScaler
    {
    }
    internal static class IImageScalerStaticsMethods
    {


        internal static unsafe global::Microsoft.Windows.AI.AIFeatureReadyState GetReadyState(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            global::Microsoft.Windows.AI.AIFeatureReadyState __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, global::Microsoft.Windows.AI.AIFeatureReadyState*, int>**)ThisPtr)[6](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double> EnsureReadyAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[7](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperationWithProgress_2_Microsoft_Windows_AI_AIFeatureReadyResult__Double.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperationWithProgress<global::Microsoft.Windows.AI.AIFeatureReadyResult, double>>.DisposeAbi(__retval);
            }
        }

        internal static unsafe global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageScaler> CreateAsync(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            IntPtr __retval = default;
            try
            {
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, IntPtr*, int>**)ThisPtr)[8](ThisPtr, &__retval));
                global::System.GC.KeepAlive(_obj);
                _ = global::WinRT.GenericTypeInstantiations.Windows_Foundation_IAsyncOperation_1_Microsoft_Graphics_Imaging_ImageScaler.EnsureInitialized();
                return MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageScaler>>.FromAbi(__retval);
            }
            finally
            {
                MarshalInterface<global::Windows.Foundation.IAsyncOperation<global::Microsoft.Graphics.Imaging.ImageScaler>>.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xDF, 0x72, 0x67, 0x2, 0x15, 0x14, 0x7A, 0x5F, 0xBD, 0x62, 0x73, 0xEE, 0xC0, 0x8E, 0xFF, 0xE6 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("026772DF-1415-5F7A-BD62-73EEC08EFFE6")]
    internal interface IImageScalerStatics : global::Microsoft.Graphics.Imaging.IImageScalerStatics
    {
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct ImageBuffer
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Graphics.Imaging.ImageBuffer obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Graphics.Imaging.ImageBuffer>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Graphics.Imaging.ImageBuffer obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Graphics.Imaging.IImageBufferMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Graphics.Imaging.ImageBuffer FromAbi(IntPtr thisPtr) => global::Microsoft.Graphics.Imaging.ImageBuffer.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Graphics.Imaging.ImageBuffer obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.MarshalerArray CreateMarshalerArray(global::Microsoft.Graphics.Imaging.ImageBuffer[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.GetAbiArray(box);
        public static unsafe global::Microsoft.Graphics.Imaging.ImageBuffer[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Graphics.Imaging.ImageBuffer[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Graphics.Imaging.ImageBuffer[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageBuffer>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class ImageBufferRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Graphics.Imaging.ImageBuffer(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct ImageObjectExtractor
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Graphics.Imaging.ImageObjectExtractor obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Graphics.Imaging.ImageObjectExtractor obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Graphics.Imaging.ImageObjectExtractor FromAbi(IntPtr thisPtr) => global::Microsoft.Graphics.Imaging.ImageObjectExtractor.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Graphics.Imaging.ImageObjectExtractor obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.MarshalerArray CreateMarshalerArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractor[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.GetAbiArray(box);
        public static unsafe global::Microsoft.Graphics.Imaging.ImageObjectExtractor[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractor[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractor[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractor>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class ImageObjectExtractorRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Graphics.Imaging.ImageObjectExtractor(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct ImageObjectExtractorHint
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectExtractorHintMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint FromAbi(IntPtr thisPtr) => global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.MarshalerArray CreateMarshalerArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.GetAbiArray(box);
        public static unsafe global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class ImageObjectExtractorHintRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Graphics.Imaging.ImageObjectExtractorHint(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct ImageObjectRemover
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Graphics.Imaging.ImageObjectRemover obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Graphics.Imaging.ImageObjectRemover obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Graphics.Imaging.IImageObjectRemoverMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Graphics.Imaging.ImageObjectRemover FromAbi(IntPtr thisPtr) => global::Microsoft.Graphics.Imaging.ImageObjectRemover.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Graphics.Imaging.ImageObjectRemover obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.MarshalerArray CreateMarshalerArray(global::Microsoft.Graphics.Imaging.ImageObjectRemover[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.GetAbiArray(box);
        public static unsafe global::Microsoft.Graphics.Imaging.ImageObjectRemover[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Graphics.Imaging.ImageObjectRemover[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Graphics.Imaging.ImageObjectRemover[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageObjectRemover>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class ImageObjectRemoverRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Graphics.Imaging.ImageObjectRemover(inspectable.ObjRef);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct ImageScaler
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Graphics.Imaging.ImageScaler obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Graphics.Imaging.ImageScaler>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Graphics.Imaging.ImageScaler obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Graphics.Imaging.IImageScalerMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Graphics.Imaging.ImageScaler FromAbi(IntPtr thisPtr) => global::Microsoft.Graphics.Imaging.ImageScaler.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Graphics.Imaging.ImageScaler obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.MarshalerArray CreateMarshalerArray(global::Microsoft.Graphics.Imaging.ImageScaler[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.GetAbiArray(box);
        public static unsafe global::Microsoft.Graphics.Imaging.ImageScaler[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Graphics.Imaging.ImageScaler[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Graphics.Imaging.ImageScaler[] array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Graphics.Imaging.ImageScaler>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class ImageScalerRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Graphics.Imaging.ImageScaler(inspectable.ObjRef);
    }
}
#pragma warning restore CA1416
