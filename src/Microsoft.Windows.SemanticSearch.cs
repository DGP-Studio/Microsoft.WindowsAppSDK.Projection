//------------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by cswinrt.exe version 2.2.0.241111.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using WinRT;
using WinRT.Interop;


#pragma warning disable 0169 // warning CS0169: The field '...' is never used
#pragma warning disable 0649 // warning CS0169: Field '...' is never assigned to
#pragma warning disable CA2207, CA1063, CA1033, CA1001, CA2213

namespace Microsoft.Windows.SemanticSearch
{
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.SemanticSearch")]
    [global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.SemanticSearch.EmbeddingVector))]
    [global::ABI.Microsoft.Windows.SemanticSearch.EmbeddingVectorRcwFactory]
    [global::WinRT.ProjectedRuntimeClass(typeof(IEmbeddingVector))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(SemanticSearchContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    public sealed class EmbeddingVector : global::System.Runtime.InteropServices.ICustomQueryInterface, IWinRTObject, IEquatable<EmbeddingVector>
    {
        private IntPtr ThisPtr => _inner == null ? (((IWinRTObject)this).NativeObject).ThisPtr : _inner.ThisPtr;

        private readonly IObjectReference _inner = null;



        private IObjectReference _objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVector => _inner;


        private static class _IEmbeddingVectorFactoryMethods
        {
            public static unsafe IntPtr CreateInstance(IObjectReference _obj, float[] data, Guid vectorSpaceID)
            {
                var ThisPtr = _obj.ThisPtr;

                MarshalBlittable<float>.MarshalerArray __data = default;
                int __data_length = default;
                IntPtr __data_data = default;
                IntPtr __retval = default;
                try
                {
                    __data = MarshalBlittable<float>.CreateMarshalerArray(data);
                    (__data_length, __data_data) = MarshalBlittable<float>.GetAbiArray(__data);
                    global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, Guid, IntPtr*, int>**)ThisPtr)[6](ThisPtr, __data_length, __data_data, vectorSpaceID, &__retval));
                    global::System.GC.KeepAlive(_obj);
                    return __retval;
                }
                finally
                {
                    MarshalBlittable<float>.DisposeMarshalerArray(__data);
                }
            }
        }

        private static volatile IObjectReference ___objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVectorFactory;
        private static IObjectReference _objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVectorFactory
        {
            get
            { 
                var factory = ___objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVectorFactory;
                if (factory != null && factory.IsInCurrentContext)
                {
                    return factory;
                }
                else
                {
                    return ___objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVectorFactory = ActivationFactory.Get("Microsoft.Windows.SemanticSearch.EmbeddingVector", global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorFactoryMethods.IID);
                }
            }
        }

        public EmbeddingVector(float[] data, Guid vectorSpaceID) 
        { 
        IntPtr ptr = (_IEmbeddingVectorFactoryMethods.CreateInstance(_objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVectorFactory, data, vectorSpaceID)); 
        try 
        { 
        _inner = ComWrappersSupport.GetObjectReferenceForInterface(ptr, global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.IID, false); 

        } 
        finally 
        { 
        MarshalInspectable<object>.DisposeAbi(ptr); 
        }

        ComWrappersSupport.RegisterObjectForInterface(this, ThisPtr);
        ComWrappersHelper.Init(_inner, false);
        }

        public static EmbeddingVector FromAbi(IntPtr thisPtr)
        {
            if (thisPtr == IntPtr.Zero) return null;
            return MarshalInspectable<EmbeddingVector>.FromAbi(thisPtr);
        }

        internal EmbeddingVector(IObjectReference objRef)
        {
            _inner = objRef.As(global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.IID);

        }


        public static bool operator ==(EmbeddingVector x, EmbeddingVector y) => (x?.ThisPtr ?? IntPtr.Zero) == (y?.ThisPtr ?? IntPtr.Zero);
        public static bool operator !=(EmbeddingVector x, EmbeddingVector y) => !(x == y);
        public bool Equals(EmbeddingVector other) => this == other;
        public override bool Equals(object obj) => obj is EmbeddingVector that && this == that;
        public override int GetHashCode() => ThisPtr.GetHashCode();


        bool IWinRTObject.HasUnwrappableNativeObject => true;
        IObjectReference IWinRTObject.NativeObject => _inner;
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> _queryInterfaceCache;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _queryInterfaceCache, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference>(), null); 
            return _queryInterfaceCache;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, IObjectReference> IWinRTObject.QueryInterfaceCache => _queryInterfaceCache ?? MakeQueryInterfaceCache();
        private volatile global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> _additionalTypeData;
        private global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> MakeAdditionalTypeData()
        {
            global::System.Threading.Interlocked.CompareExchange(ref _additionalTypeData, new global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object>(), null); 
            return _additionalTypeData;
        }
        global::System.Collections.Concurrent.ConcurrentDictionary<RuntimeTypeHandle, object> IWinRTObject.AdditionalTypeData => _additionalTypeData ?? MakeAdditionalTypeData();

        private struct InterfaceTag<I>{};


        public void GetValues(float[] values) => global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.GetValues(_objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVector, values);

        public uint Size => global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.get_Size(_objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVector);

        public Guid VectorSpaceId => global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.get_VectorSpaceId(_objRef_global__Microsoft_Windows_SemanticSearch_IEmbeddingVector);

        private bool IsOverridableInterface(Guid iid) => false;

        global::System.Runtime.InteropServices.CustomQueryInterfaceResult global::System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(ref Guid iid, out IntPtr ppv)
        {
            ppv = IntPtr.Zero;
            if (IsOverridableInterface(iid) || global::WinRT.Interop.IID.IID_IInspectable == iid)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
            }

            if (((IWinRTObject)this).NativeObject.TryAs(iid, out ppv) >= 0)
            {
                return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.Handled;
            }

            return global::System.Runtime.InteropServices.CustomQueryInterfaceResult.NotHandled;
        }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.SemanticSearch")][Guid("F80248AA-68E7-5DE0-9166-B26E58935D34")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVector))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(SemanticSearchContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IEmbeddingVector
    {
        void GetValues(float[] values);
        uint Size { get; }
        Guid VectorSpaceId { get; }
    }
    [global::WinRT.WindowsRuntimeType("Microsoft.Windows.SemanticSearch")][Guid("3A31EAD7-1F01-5A4C-9C2E-9ACFA6495CDD")][global::WinRT.WindowsRuntimeHelperType(typeof(global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorFactory))]
    [global::Windows.Foundation.Metadata.ContractVersion(typeof(SemanticSearchContract), 65536u)]
    [global::Windows.Foundation.Metadata.Experimental]
    internal interface IEmbeddingVectorFactory
    {
        EmbeddingVector CreateInstance(float[] data, Guid vectorSpaceID);
    }
    [global::Windows.Foundation.Metadata.ContractVersion(65536u)]
    public enum SemanticSearchContract
    {
    }
}

#pragma warning disable CA1416
namespace ABI.Microsoft.Windows.SemanticSearch
{
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    public struct EmbeddingVector
    {

        public static IObjectReference CreateMarshaler(global::Microsoft.Windows.SemanticSearch.EmbeddingVector obj) => obj is null ? null : MarshalInspectable<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.CreateMarshaler<IUnknownVftbl>(obj, global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.IID);
        public static ObjectReferenceValue CreateMarshaler2(global::Microsoft.Windows.SemanticSearch.EmbeddingVector obj) => MarshalInspectable<object>.CreateMarshaler2(obj, global::ABI.Microsoft.Windows.SemanticSearch.IEmbeddingVectorMethods.IID);
        public static IntPtr GetAbi(IObjectReference value) => value is null ? IntPtr.Zero : MarshalInterfaceHelper<object>.GetAbi(value);
        public static global::Microsoft.Windows.SemanticSearch.EmbeddingVector FromAbi(IntPtr thisPtr) => global::Microsoft.Windows.SemanticSearch.EmbeddingVector.FromAbi(thisPtr);
        public static IntPtr FromManaged(global::Microsoft.Windows.SemanticSearch.EmbeddingVector obj) => obj is null ? IntPtr.Zero : CreateMarshaler2(obj).Detach();
        public static unsafe MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.MarshalerArray CreateMarshalerArray(global::Microsoft.Windows.SemanticSearch.EmbeddingVector[] array) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.CreateMarshalerArray2(array, (o) => CreateMarshaler2(o));
        public static (int length, IntPtr data) GetAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.GetAbiArray(box);
        public static unsafe global::Microsoft.Windows.SemanticSearch.EmbeddingVector[] FromAbiArray(object box) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.FromAbiArray(box, FromAbi);
        public static void CopyAbiArray(global::Microsoft.Windows.SemanticSearch.EmbeddingVector[] array, object box) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.CopyAbiArray(array, box, FromAbi);
        public static (int length, IntPtr data) FromManagedArray(global::Microsoft.Windows.SemanticSearch.EmbeddingVector[] array) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.FromManagedArray(array, (o) => FromManaged(o));
        public static void DisposeMarshaler(IObjectReference value) => MarshalInspectable<object>.DisposeMarshaler(value);
        public static void DisposeMarshalerArray(MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.MarshalerArray array) => MarshalInterfaceHelper<global::Microsoft.Windows.SemanticSearch.EmbeddingVector>.DisposeMarshalerArray(array);
        public static void DisposeAbi(IntPtr abi) => MarshalInspectable<object>.DisposeAbi(abi);
        public static unsafe void DisposeAbiArray(object box) => MarshalInspectable<object>.DisposeAbiArray(box);
    }
    [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
    internal sealed class EmbeddingVectorRcwFactoryAttribute : global::WinRT.WinRTImplementationTypeRcwFactoryAttribute
    {
        public override object CreateInstance(global::WinRT.IInspectable inspectable)
            => new global::Microsoft.Windows.SemanticSearch.EmbeddingVector(inspectable.ObjRef);
    }
    internal static class IEmbeddingVectorMethods
    {


        internal static unsafe void GetValues(IObjectReference _obj, float[] values)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<float>.MarshalerArray __values = default;
            int __values_length = default;
            IntPtr __values_data = default;
            try
            {
                __values = MarshalBlittable<float>.CreateMarshalerArray(values);
                (__values_length, __values_data) = MarshalBlittable<float>.GetAbiArray(__values);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, int>**)ThisPtr)[6](ThisPtr, __values_length, __values_data));
                global::System.GC.KeepAlive(_obj);
            }
            finally
            {
                MarshalBlittable<float>.DisposeMarshalerArray(__values);
            }
        }
        internal static unsafe uint get_Size(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            uint __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, uint*, int>**)ThisPtr)[7](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }

        internal static unsafe Guid get_VectorSpaceId(IObjectReference _obj)
        {
            var ThisPtr = _obj.ThisPtr;

            Guid __retval = default;
            global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, Guid*, int>**)ThisPtr)[8](ThisPtr, &__retval));
            global::System.GC.KeepAlive(_obj);
            return __retval;
        }



        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xAA, 0x48, 0x2, 0xF8, 0xE7, 0x68, 0xE0, 0x5D, 0x91, 0x66, 0xB2, 0x6E, 0x58, 0x93, 0x5D, 0x34 };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("F80248AA-68E7-5DE0-9166-B26E58935D34")]
    internal interface IEmbeddingVector : global::Microsoft.Windows.SemanticSearch.IEmbeddingVector
    {
    }
    internal static class IEmbeddingVectorFactoryMethods
    {


        internal static unsafe global::Microsoft.Windows.SemanticSearch.EmbeddingVector CreateInstance(IObjectReference _obj, float[] data, Guid vectorSpaceID)
        {
            var ThisPtr = _obj.ThisPtr;

            MarshalBlittable<float>.MarshalerArray __data = default;
            int __data_length = default;
            IntPtr __data_data = default;
            IntPtr __retval = default;
            try
            {
                __data = MarshalBlittable<float>.CreateMarshalerArray(data);
                (__data_length, __data_data) = MarshalBlittable<float>.GetAbiArray(__data);
                global::WinRT.ExceptionHelpers.ThrowExceptionForHR((*(delegate* unmanaged[Stdcall]<IntPtr, int, IntPtr, Guid, IntPtr*, int>**)ThisPtr)[6](ThisPtr, __data_length, __data_data, vectorSpaceID, &__retval));
                global::System.GC.KeepAlive(_obj);
                return global::ABI.Microsoft.Windows.SemanticSearch.EmbeddingVector.FromAbi(__retval);
            }
            finally
            {
                MarshalBlittable<float>.DisposeMarshalerArray(__data);
                global::ABI.Microsoft.Windows.SemanticSearch.EmbeddingVector.DisposeAbi(__retval);
            }
        }


        public static ref readonly global::System.Guid IID
        {
            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            get
            {
                global::System.ReadOnlySpan<byte> data = new byte[] { 0xD7, 0xEA, 0x31, 0x3A, 0x1, 0x1F, 0x4C, 0x5A, 0x9C, 0x2E, 0x9A, 0xCF, 0xA6, 0x49, 0x5C, 0xDD };
                return ref global::System.Runtime.CompilerServices.Unsafe.As<byte, global::System.Guid>(ref global::System.Runtime.InteropServices.MemoryMarshal.GetReference(data));
            }
        }

    }
    [Guid("3A31EAD7-1F01-5A4C-9C2E-9ACFA6495CDD")]
    internal interface IEmbeddingVectorFactory : global::Microsoft.Windows.SemanticSearch.IEmbeddingVectorFactory
    {
    }
}
#pragma warning restore CA1416
